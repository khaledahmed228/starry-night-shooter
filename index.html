<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Masterpiece Bubbles - Smooth Touch</title>
    <style>
        :root { --gold: #fbff00; --bg-dark: rgba(10, 25, 47, 0.9); }
        body { 
            background: #050505 url('monalisa.png') no-repeat center center fixed;
            background-size: cover !important; 
            display: flex; flex-direction: column; align-items: center; 
            min-height: 100vh; margin: 0; font-family: 'Segoe UI', sans-serif; 
            overflow: hidden; color: white; touch-action: none;
        }
        #main-layout { display: flex; flex-direction: column; align-items: center; gap: 10px; padding: 10px; width: 100%; }
        #game-container { position: relative; background: var(--bg-dark); padding: 10px; border-radius: 20px; border: 3px solid var(--gold); width: fit-content; }
        canvas { background: rgba(0, 0, 0, 0.7); border-radius: 12px; display: block; touch-action: none; }
        .side-panel { width: 95%; background: var(--bg-dark); padding: 10px; border-radius: 20px; border: 2px solid var(--gold); display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; justify-content: center; }
        .stat-box { flex: 1; min-width: 70px; text-align: center; background: rgba(255,255,255,0.05); padding: 5px; border-radius: 10px; border-bottom: 2px solid var(--gold); }
        .stat-label { font-size: 10px; color: var(--gold); }
        .stat-value { font-size: 18px; font-weight: bold; }
        button { padding: 8px 15px; border: none; border-radius: 15px; font-weight: bold; cursor: pointer; background: linear-gradient(to bottom, #fbff00, #c4a700); color: black; font-size: 13px; }
        #overlay { position: absolute; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; border-radius: 18px; }
        .level-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-bottom: 15px; }
        .lvl-btn { width: 40px; height: 40px; border: 2px solid var(--gold); border-radius: 50%; display: flex; align-items: center; justify-content: center; }
    </style>
</head>
<body>

<audio id="bg-music" loop><source src="Chopin - Nocturne op.9 No.2.mp3" type="audio/mpeg"></audio>

<div id="main-layout">
    <div id="game-container">
        <div id="overlay">
            <h1 style="color:var(--gold); margin-bottom:20px;">MASTERPIECE</h1>
            <div id="menu-content" style="width: 80%; display: flex; flex-direction: column; gap: 10px;">
                <button onclick="startLevel(unlockedLevel)">Ø§Ø³ØªÙ…Ø±Ø§Ø±</button>
                <button style="background:none; border:2px solid var(--gold); color:var(--gold);" onclick="showLevelsMenu()">Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª</button>
            </div>
        </div>
        <canvas id="gameCanvas"></canvas>
    </div>

    <div class="side-panel">
        <div class="stat-box"><div class="stat-label">Ø§Ù„Ù…Ø³ØªÙˆÙ‰</div><div class="stat-value" id="cur-lvl">1</div></div>
        <div class="stat-box"><div class="stat-label">Ø§Ù„Ù†Ù‚Ø§Ø·</div><div class="stat-value" id="score-val">0</div></div>
        <button onclick="showLevelsMenu()">Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª</button>
        <button id="mute-btn">ðŸ”Š Unmute</button>
    </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const music = document.getElementById('bg-music');

// Ù…Ù‚Ø§Ø³Ø§Øª Ø°ÙƒÙŠØ© Ù„Ù„Ù…ÙˆØ¨Ø§ÙŠÙ„
const screenW = window.innerWidth;
const screenH = window.innerHeight;
canvas.width = Math.min(screenW - 30, 400);
canvas.height = Math.min(screenH - 180, 550);

const COLORS = ['#FF3E3E', '#3EFF3E', '#3E8BFF', '#FFFF3E', '#FF3EFF', '#FF8B3E'];
const RADIUS = canvas.width / 21; // Ù…Ù‚Ø§Ø³ Ø§Ù„ÙƒÙˆØ±Ø© Ù†Ø³Ø¨ÙŠ Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø´Ø§Ø´Ø©
const ROWS = 14; const COLS = 10;
let grid = [], score = 0, currentLevel = 1, shots = 0;
let unlockedLevel = parseInt(localStorage.getItem('art_v12_save')) || 1;
let currentBubble = null, nextColor = COLORS[0], isShooting = false;
let falling = [];

// Ø³Ù„Ø§Ø³Ø© Ø§Ù„ØªÙ†Ø´ÙŠÙ†
let isPressing = false;
let pX = 0, pY = 0, sX = 0, sY = 0;

function drawBubble(x, y, color, alpha = 1, r = RADIUS) {
    ctx.save(); ctx.globalAlpha = alpha;
    let grad = ctx.createRadialGradient(x - r/3, y - r/3, r/10, x, y, r);
    grad.addColorStop(0, '#FFFFFF'); grad.addColorStop(0.3, color); grad.addColorStop(1, '#000000');
    ctx.beginPath(); ctx.arc(x, y, r - 1, 0, Math.PI * 2);
    ctx.fillStyle = grad; ctx.fill(); ctx.restore();
}

function initGrid() {
    grid = [];
    for (let r = 0; r < ROWS; r++) {
        grid[r] = [];
        let offset = (r % 2 !== 0) ? RADIUS : 0;
        for (let c = 0; c < COLS; c++) {
            grid[r][c] = { x: c * RADIUS * 2 + RADIUS + offset, y: r * RADIUS * 1.75 + RADIUS, color: '', active: false };
        }
    }
}

function drawAim() {
    if (isShooting || !isPressing || !currentBubble || pY > canvas.height - 80) return;
    let cx = canvas.width/2, cy = canvas.height-50;
    let ang = Math.atan2(pY - cy, pX - cx);
    let vx = Math.cos(ang)*22, vy = Math.sin(ang)*22;
    
    ctx.save();
    ctx.setLineDash([5, 8]);
    for(let i=0; i<25; i++) {
        cx += vx; cy += vy;
        if(cx < RADIUS || cx > canvas.width-RADIUS) vx *= -1;
        if(cy < RADIUS || checkCollision(cx, cy)) break;
        ctx.beginPath(); ctx.arc(cx, cy, 2.5, 0, Math.PI*2);
        ctx.fillStyle = `rgba(251, 255, 0, ${1 - i/25})`; ctx.fill();
    }
    ctx.restore();
}

function checkCollision(x, y) {
    for(let r=0; r<ROWS; r++) {
        for(let c=0; c<COLS; c++) {
            if(grid[r][c].active && Math.hypot(x-grid[r][c].x, y-grid[r][c].y) < RADIUS*1.3) return true;
        }
    }
    return false;
}

function snap() {
    isShooting = false;
    let bestDist = Infinity, tr = 0, tc = 0;
    for(let r=0; r<ROWS; r++) {
        for(let c=0; c<COLS; c++) {
            if(!grid[r][c].active) {
                let d = Math.hypot(currentBubble.x - grid[r][c].x, currentBubble.y - grid[r][c].y);
                if(d < bestDist) { bestDist = d; tr = r; tc = c; }
            }
        }
    }
    grid[tr][tc].active = true; grid[tr][tc].color = currentBubble.color;
    let matches = []; findMatch(tr, tc, grid[tr][tc].color, matches);
    if(matches.length >= 3) {
        matches.forEach(m => {
            falling.push({x: grid[m.r][m.c].x, y: grid[m.r][m.c].y, color: grid[m.r][m.c].color, vx: (Math.random()-0.5)*8, vy: 2});
            grid[m.r][m.c].active = false;
        });
        score += matches.length * 20;
        dropFloaters();
    }
    shots++; if(shots % 8 === 0) pushRows();
    currentBubble = { x: canvas.width/2, y: canvas.height-50, color: nextColor };
    nextColor = COLORS[Math.floor(Math.random()*COLORS.length)];
    checkWin(); updateUI();
}

function findMatch(r, c, col, list) {
    let key = `${r},${c}`;
    if(r<0||r>=ROWS||c<0||c>=COLS||!grid[r][c].active||grid[r][c].color!==col||list.some(m=>m.key===key)) return;
    list.push({r, c, key});
    let n = (r%2!==0) ? [[r,c-1],[r,c+1],[r-1,c],[r-1,c+1],[r+1,c],[r+1,c+1]] : [[r,c-1],[r,c+1],[r-1,c-1],[r-1,c],[r+1,c-1],[r+1,c]];
    n.forEach(d => findMatch(d[0], d[1], col, list));
}

function dropFloaters() {
    let conn = new Set();
    for(let c=0; c<COLS; c++) if(grid[0][c].active) fillConn(0, c, conn);
    for(let r=0; r<ROWS; r++) for(let c=0; c<COLS; c++) {
        if(grid[r][c].active && !conn.has(`${r},${c}`)) {
            falling.push({x:grid[r][c].x, y:grid[r][c].y, color:grid[r][c].color, vx:(Math.random()-0.5)*5, vy:4});
            grid[r][c].active = false; score += 30;
        }
    }
}

function fillConn(r, c, set) {
    if(r<0||r>=ROWS||c<0||c>=COLS||!grid[r][c].active||set.has(`${r},${c}`)) return;
    set.add(`${r},${c}`);
    let n = (r%2!==0) ? [[r,c-1],[r,c+1],[r-1,c],[r-1,c+1],[r+1,c],[r+1,c+1]] : [[r,c-1],[r,c+1],[r-1,c-1],[r-1,c],[r+1,c-1],[r+1,c]];
    n.forEach(d => fillConn(d[0], d[1], set));
}

function pushRows() {
    for(let r=ROWS-1; r>0; r--) for(let c=0; c<COLS; c++) { grid[r][c].active = grid[r-1][c].active; grid[r][c].color = grid[r-1][c].color; }
    for(let c=0; c<COLS; c++) { grid[0][c].active = true; grid[0][c].color = COLORS[Math.floor(Math.random()*COLORS.length)]; }
}

function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Ø±Ø³Ù… Ø§Ù„Ù…Ø¨Ø¯Ù„ Ø§Ù„ØµØºÙŠØ±
    ctx.beginPath(); ctx.arc(canvas.width/2 + 40, canvas.height-35, 12, 0, Math.PI*2);
    ctx.fillStyle = "rgba(251, 255, 0, 0.1)"; ctx.fill();
    drawBubble(canvas.width/2 + 40, canvas.height-35, nextColor, 1, 8);

    drawAim();
    grid.forEach(row => row.forEach(b => { if(b.active) drawBubble(b.x, b.y, b.color); }));
    
    falling = falling.filter(f => {
        f.x += f.vx; f.y += f.vy; f.vy += 0.4;
        drawBubble(f.x, f.y, f.color, 0.6);
        return f.y < canvas.height + 50;
    });

    if(currentBubble) {
        if(isShooting) {
            currentBubble.x += currentBubble.vx; currentBubble.y += currentBubble.vy;
            if(currentBubble.x < RADIUS || currentBubble.x > canvas.width-RADIUS) currentBubble.vx *= -1;
            if(currentBubble.y < RADIUS || checkCollision(currentBubble.x, currentBubble.y)) snap();
        }
        drawBubble(currentBubble.x, currentBubble.y, currentBubble.color);
    }
    requestAnimationFrame(loop);
}

// Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù„Ù…Ø³ Ø¨Ø¯Ù‚Ø© ÙˆÙ†Ø¹ÙˆÙ…Ø©
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    if(isShooting || document.getElementById('overlay').style.display !== 'none') return;
    isPressing = true;
    let r = canvas.getBoundingClientRect();
    sX = e.touches[0].clientX - r.left; sY = e.touches[0].clientY - r.top;
    pX = sX; pY = sY;
}, {passive: false});

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if(!isPressing) return;
    let r = canvas.getBoundingClientRect();
    pX = e.touches[0].clientX - r.left; pY = e.touches[0].clientY - r.top;
}, {passive: false});

canvas.addEventListener('touchend', e => {
    e.preventDefault();
    if(!isPressing) return;
    isPressing = false;
    let dist = Math.hypot(pX - sX, pY - sY);
    if (dist < 20) {
        let t = currentBubble.color; currentBubble.color = nextColor; nextColor = t;
    } else if (pY < canvas.height - 70) {
        let ang = Math.atan2(pY - (canvas.height-50), pX - (canvas.width/2));
        currentBubble.vx = Math.cos(ang)*17; // Ø³Ø±Ø¹Ø© Ù†Ø§Ø¹Ù…Ø©
        currentBubble.vy = Math.sin(ang)*17;
        isShooting = true;
    }
}, {passive: false});

function startLevel(lv) {
    currentLevel = lv; score = 0; shots = 0;
    document.body.style.backgroundImage = "url('starry night.png')";
    document.getElementById('overlay').style.display = 'none';
    initGrid();
    for(let r=0; r < 4 + Math.floor(lv/4); r++) for(let c=0; c<COLS; c++) {
        grid[r][c].active = true; grid[r][c].color = COLORS[Math.floor(Math.random()*COLORS.length)];
    }
    currentBubble = { x: canvas.width/2, y: canvas.height-50, color: COLORS[Math.floor(Math.random()*COLORS.length)] };
    music.play().catch(()=>{}); updateUI();
}

function showLevelsMenu() {
    document.body.style.backgroundImage = "url('The Scream.png')";
    document.getElementById('overlay').style.display = 'flex';
    let h = '<div class="level-grid">';
    for(let i=1; i<=12; i++) h += `<div class="lvl-btn ${i>unlockedLevel?'locked':''}" onclick="${i>unlockedLevel?'':'startLevel('+i+')'}">${i}</div>`;
    h += '</div><button onclick="document.getElementById(\'overlay\').style.display=\'none\'">Ø±Ø¬ÙˆØ¹</button>';
    document.getElementById('menu-content').innerHTML = h;
}

function checkWin() {
    if(score >= 500 + currentLevel*200) {
        unlockedLevel = Math.max(unlockedLevel, currentLevel + 1);
        localStorage.setItem('art_v12_save', unlockedLevel);
        showLevelsMenu();
    }
}

function updateUI() {
    document.getElementById('cur-lvl').innerText = currentLevel;
    document.getElementById('score-val').innerText = score;
}

document.getElementById('mute-btn').onclick = () => {
    music.muted = !music.muted;
    document.getElementById('mute-btn').innerText = music.muted ? "ðŸ”Š Unmute" : "ðŸ”‡ Mute";
};

initGrid(); loop();
</script>
</body>
</html>